<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POL Price Proxy - Conexão Garantida</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
    <style>
        /* Estilos mantidos iguais */
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; }
        .container { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        button { background: #8247e5; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; margin: 5px 0; width: 100%; }
        button:disabled { background: #cccccc; cursor: not-allowed; }
        input { padding: 8px; margin: 5px 0; width: 100%; box-sizing: border-box; }
        .section { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .balance { font-weight: bold; }
        #networkWarning { color: red; font-weight: bold; display: none; padding: 10px; background: #ffeeee; border-radius: 5px; }
        .status-message { padding: 10px; margin: 5px 0; border-radius: 5px; display: none; }
        .success { background: #e6ffee; color: #009900; }
        .error { background: #ffeeee; color: #cc0000; }
        .info { background: #e6f3ff; color: #0066cc; }
    </style>
</head>
<body>
    <div class="container">
        <h1>POL Price Proxy - Conexão Garantida</h1>
        <p id="networkWarning">⚠️ Por favor, conecte-se à Polygon Mainnet no MetaMask!</p>
        
        <!-- Seção Carteira -->
        <div class="section">
            <h2>1. Conexão da Carteira</h2>
            <button id="connectWallet">Conectar MetaMask</button>
            <div id="walletInfo" style="display: none;">
                <p>Conectado: <span id="walletAddress"></span></p>
                <div class="balance">Saldo MATIC: <span id="maticBalance"></span></div>
                <div class="balance">Saldo POL: <span id="polBalance"></span></div>
                <div class="balance">Saldo USDC: <span id="usdcBalance"></span></div>
            </div>
        </div>

    <script>
        // Configurações
        const contractAddress = "0x6Cc8B4a08be3D8e0C7Ef0F4C9eF1cD336f6DDc4d";
        const polTokenAddress = "0x455e53CBB86018Ac2B8092FdCd39d8444aFFC3F6";
        const usdcTokenAddress = "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174";
        const quickSwapRouter = "0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff";
        const polygonChainId = "0x89"; // Polygon Mainnet

        // ABI Simplificada
        const contractABI = [
            {"inputs":[],"name":"togglePriceOverride","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountPOL","type":"uint256"}],"name":"swapPOLForUSDC","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"priceOverrideActive","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"FIXED_PRICE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
        ];

        const erc20ABI = [
            {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},
            {"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"type":"function"},
            {"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"type":"function"}
        ];

        // Variáveis globais
        let web3;
        let accounts;
        let contract;
        let polToken;
        let usdcToken;
        let priceOverrideEnabled = false;

        // Inicialização
        window.addEventListener('load', async () => {
            if (window.ethereum) {
                web3 = new Web3(window.ethereum);
                
                // Event Listeners
                document.getElementById('connectWallet').addEventListener('click', connectWallet);
                document.getElementById('toggleOverride').addEventListener('click', togglePriceOverride);
                document.getElementById('executeSwap').addEventListener('click', executeSwap);
                document.getElementById('polAmount').addEventListener('input', updateExpectedUSDC);
                
                // Verifica se já está conectado
                try {
                    accounts = await web3.eth.getAccounts();
                    if (accounts.length > 0) {
                        await checkNetwork();
                        initContracts();
                        await updateUI();
                    }
                } catch (error) {
                    console.error("Erro ao verificar conexão existente:", error);
                }
                
                // Listeners de eventos da MetaMask
                window.ethereum.on('accountsChanged', (newAccounts) => {
                    accounts = newAccounts;
                    if (accounts.length > 0) {
                        updateUI();
                    } else {
                        document.getElementById('walletInfo').style.display = 'none';
                    }
                });

                window.ethereum.on('chainChanged', () => {
                    window.location.reload();
                });
            } else {
                alert("Por favor instale o MetaMask para usar esta aplicação!");
            }
        });

        // Função para conectar carteira
        async function connectWallet() {
            try {
                showMessage("Conectando à carteira...", "info");
                accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                const networkOk = await checkNetwork();
                if (!networkOk) return;
                
                initContracts();
                await updateUI();
                
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('walletAddress').textContent = accounts[0];
                
                showMessage("Carteira conectada com sucesso!", "success");
            } catch (error) {
                console.error("Erro ao conectar carteira:", error);
                showMessage("Erro ao conectar: " + (error.message || "Usuário rejeitou a conexão"), "error");
            }
        }

        // Função para verificar rede
        async function checkNetwork() {
            try {
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                
                if (chainId !== polygonChainId) {
                    document.getElementById('networkWarning').style.display = 'block';
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: polygonChainId }],
                        });
                        document.getElementById('networkWarning').style.display = 'none';
                        return true;
                    } catch (switchError) {
                        showMessage("Por favor conecte-se à Polygon Mainnet no MetaMask", "error");
                        return false;
                    }
                }
                
                document.getElementById('networkWarning').style.display = 'none';
                return true;
            } catch (error) {
                console.error("Erro ao verificar rede:", error);
                return false;
            }
        }

        // Inicializa contratos
        function initContracts() {
            contract = new web3.eth.Contract(contractABI, contractAddress);
            polToken = new web3.eth.Contract(erc20ABI, polTokenAddress);
            usdcToken = new web3.eth.Contract(erc20ABI, usdcTokenAddress);
        }

        // Atualiza a interface
        async function updateUI() {
            if (!accounts || accounts.length === 0) return;

            try {
                // Atualiza saldos
                const maticBalance = await web3.eth.getBalance(accounts[0]);
                const polBalance = await polToken.methods.balanceOf(accounts[0]).call();
                const usdcBalance = await usdcToken.methods.balanceOf(accounts[0]).call();

                document.getElementById('maticBalance').textContent = web3.utils.fromWei(maticBalance, 'ether').substring(0, 8) + " MATIC";
                document.getElementById('polBalance').textContent = web3.utils.fromWei(polBalance, 'ether').substring(0, 8) + " POL";
                document.getElementById('usdcBalance').textContent = (usdcBalance / 10**6).toFixed(2) + " USDC";

                // Atualiza status do preço fixo
                priceOverrideEnabled = await contract.methods.priceOverrideActive(accounts[0]).call();
                updateOverrideStatus();

                // Atualiza preço da QuickSwap
                await updateQuickSwapPrice();
            } catch (error) {
                console.error("Erro ao atualizar UI:", error);
            }
        }

        // Atualiza status do preço fixo
        function updateOverrideStatus() {
            const statusElement = document.getElementById('overrideStatus');
            if (priceOverrideEnabled) {
                statusElement.textContent = "Status: Ativo";
                statusElement.style.color = "green";
                document.getElementById('toggleOverride').textContent = "Desativar Preço Fixo";
            } else {
                statusElement.textContent = "Status: Inativo";
                statusElement.style.color = "red";
                document.getElementById('toggleOverride').textContent = "Ativar Preço Fixo";
            }
        }

        // Atualiza preço da QuickSwap
        async function updateQuickSwapPrice() {
            try {
                const amountIn = web3.utils.toWei('1', 'ether');
                const path = [polTokenAddress, usdcTokenAddress];
                
                const router = new web3.eth.Contract([
                    {
                        "inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"}],
                        "name":"getAmountsOut",
                        "outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],
                        "stateMutability":"view","type":"function"
                    }
                ], quickSwapRouter);

                const amounts = await router.methods.getAmountsOut(amountIn, path).call();
                const price = amounts[1] / 10**6;
                document.getElementById('quickSwapPrice').textContent = price.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                
                // Habilita/desabilita botão de swap baseado no preço
                document.getElementById('executeSwap').disabled = price > 312000 || !priceOverrideEnabled;
            } catch (error) {
                console.error("Erro ao buscar preço:", error);
                document.getElementById('quickSwapPrice').textContent = "Erro ao carregar";
            }
        }

        // Alterna preço fixo
        async function togglePriceOverride() {
            try {
                showMessage("Processando...", "info");
                await contract.methods.togglePriceOverride().send({ from: accounts[0] });
                priceOverrideEnabled = await contract.methods.priceOverrideActive(accounts[0]).call();
                updateOverrideStatus();
                await updateQuickSwapPrice();
                showMessage("Preço fixo " + (priceOverrideEnabled ? "ativado" : "desativado") + " com sucesso!", "success");
            } catch (error) {
                console.error("Erro ao alternar preço fixo:", error);
                showMessage("Erro: " + (error.message || "Transação falhou"), "error");
            }
        }

        // Atualiza USDC esperado
        function updateExpectedUSDC() {
            const polAmount = parseFloat(document.getElementById('polAmount').value);
            if (!isNaN(polAmount) {
                const usdcAmount = polAmount * 312000;
                document.getElementById('expectedUSDC').textContent = usdcAmount.toLocaleString('pt-BR', {minimumFractionDigits: 2, maximumFractionDigits: 2});
            } else {
                document.getElementById('expectedUSDC').textContent = "0";
            }
        }

        // Executa o swap
        async function executeSwap() {
            const polAmount = document.getElementById('polAmount').value;
            if (!polAmount || isNaN(polAmount)) {
                showMessage("Insira uma quantidade válida de POL", "error");
                return;
            }

            const polWei = web3.utils.toWei(polAmount, 'ether');
            showMessage("Iniciando transação... Por favor, assine no MetaMask", "info");

            try {
                // Verifica aprovação
                const allowance = await polToken.methods.allowance(accounts[0], contractAddress).call();
                if (allowance < polWei) {
                    showMessage("Aprovando tokens POL...", "info");
                    await polToken.methods.approve(contractAddress, polWei).send({ from: accounts[0] });
                }

                // Executa o swap
                showMessage("Executando swap...", "info");
                await contract.methods.swapPOLForUSDC(polWei).send({ from: accounts[0] });
                
                showMessage("✔️ Swap executado com sucesso!", "success");
                updateUI();
            } catch (error) {
                console.error("Erro no swap:", error);
                showMessage("❌ Erro: " + (error.message || "Transação falhou"), "error");
            }
        }

        // Mostra mensagens de status
        function showMessage(message, type) {
            const statusElement = document.getElementById('swapStatus');
            statusElement.textContent = message;
            statusElement.className = "status-message " + type;
            statusElement.style.display = "block";
            
            // Limpa mensagens após 10 segundos
            if (type !== "info") {
                setTimeout(() => {
                    statusElement.style.display = "none";
                }, 10000);
            }
        }
    </script>
</body>
</html>
